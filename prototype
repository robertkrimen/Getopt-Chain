#!/usr/bin/env perl

use strict;
use warnings;

package GtC;

use Any::Moose;
use Carp;

use Path::StepDispatcher;
#use Carp::Always;

has builder => qw/ is ro lazy_build 1 /;
sub _build_builder {
    my $self = shift;
    return Path::StepDispatcher::Builder->new(
        parse_rule => \&_parse_rule,
        parse_switch => \&_parse_switch,
    );
}

has dispatcher => qw/ is ro lazy_build 1 /;
sub _build_dispatcher {
    my $self = shift;
    return Path::StepDispatcher->new(
        root => $self->builder->build_switch,
        build_context => 'GtC::Context',
    );
}

sub is_option_like ($) {
    return $_[0] =~ m/^-/;
}

use Getopt::Long qw/GetOptionsFromArray/;
sub consume_arguments ($$) { # Will modify arguments, reflecting consumption
    my $argument_schema = shift;
    my $arguments = shift;

    my %options;
    eval {
        if ( $argument_schema && @$argument_schema ) {
            Getopt::Long::Configure(qw/ pass_through /);
            GetOptionsFromArray( $arguments, \%options, @$argument_schema );
        }
    };
    croak "There was an error option-processing arguments: $@" if $@;

    return ( \%options );
}

sub parse_argument_schema {
    my $self = shift;
    my $argument_schema = shift;
    return sub {
        my $ctx = shift;
        my $arguments = [ grep { length && m/\S/ } split m/\s/, $ctx->path ];
        my $options;
        eval {
            $options = consume_arguments $argument_schema, $arguments;
            # TODO die "Unknown option-like argument" unless $ctx->local->is_terminal
        };
        die $@ if $@;
        $ctx->path( join ' ', @$arguments ); # TODO How should we reconstitute the path?
    };
}

sub _parse_rule {
    my $builder = shift;
    my $input = shift;

    if ( defined $input && ref $input eq '' ) {
        $input = qr/$input/;
    }

    return $builder->builtin_parse_rule( $input );
}

sub _parse_switch {
    my $builder = shift;
    my $rule = shift;
    if ( ref $_[0] eq 'ARRAY' ) {
        unshift @_, __PACKAGE__->parse_argument_schema( shift @_ );
    }

    return $builder->builtin_parse_switch( $rule, @_ );
}

package GtC::Context;

use Any::Moose;

extends qw/Path::StepDispatcher::Context/;

1;

package main;

use Test::Most;

plan qw/no_plan/;

my $gtc = GtC->new();

ok( $gtc );
ok( $gtc->dispatcher );

sub path {
    return $gtc->builder->parse_switch( @_ );
}

$gtc->dispatcher->root->add(
    path( "apple", [ qw/ a1 b2:s / ],
        sub {
            my $ctx = shift;
            warn "At apple\n";
        },
        path ( "banana", 
            sub {
                my $ctx = shift;
                warn "At banana\n";
            }
        ),
    ),
);

$gtc->dispatcher->dispatch( "apple --a1 banana" );

1;
